/*
* 堆是一种近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或者索引总是小于（或大于）它的父结点。
* 堆排序可以说是一种利用堆的概念来排序的选择排序。分为两两种方法：
* 大顶堆：每个结点的值都大于等于其子结点的值，用于升序排序
* 小顶堆：每个结点的值都小于等于其子结点的值，用于降序排序
*/

/*平均时间复杂度O(n*logn)*/

/*核心步骤
a.将无序序列构建成一个堆，根据升序降序需求选择大顶堆或小顶堆;

b.将堆顶元素与末尾元素交换，将最大元素"沉"到数组末端;

c.重新调整结构，使其满足堆定义，然后继续交换堆顶元素与当前末尾元素，反复执行调整+交换步骤，直到整个序列有序。
*/

/*本函数完成在数组R[low]到R[high]的范围内对在位置low上的结点进行调整*/
void shift(int arr[], int low, int high)
{
	int i = low, j = 2 * i; //arr[j]是arr[i]的左孩子
	int temp = arr[i];
	while (j <= high)
	{
		if (j < high && arr[j] < arr[j + 1])//如果右孩子比左孩子大，则把j指向右孩子
			j++;
		if (temp < arr[j])
		{
			arr[i] = arr[j];//将arr[j]调整到双亲节点的位置上
			i = j;//修改i和j的值以便继续向下调整
			j = 2 * i;
		}
		else
			break;//调整结束
	}
	arr[i] = temp;//被调整结点的值放入最终位置
}


/*堆排序函数*/
void heap_sort(int arr[], int len)
{
	int i;
	int temp;
	for (i = len / 2; i >= 1; i--)//建立初始堆
		shift(arr, i, len);

	for (i = len; i >= 2; i++)
	{
		/*下面三句交换出根节点，将其放入最终位置，假设下标1是序列的开始*/
		temp = arr[i];
		arr[1] = arr[i];
		arr[i] = temp;
		shift(arr, 1, i - 1);//在减少了一个关键字的无序排列中进行调整
	}
}